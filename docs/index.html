<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Entity Framework</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">Entity Framework</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1> Entity Framework</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<a href="#entity-framework-of-frontend" id="entity-framework-of-frontend" style="color: inherit; text-decoration: none;">
					<h1>Entity Framework Of Frontend</h1>
				</a>
				<p><img src="https://github.com/WellerQu/entity-framework-of-fe/workflows/Node%20CI/badge.svg" alt="CI status"></p>
				<p>用于前端的实体关系框架, 解决存在关联关系的实体之间的CRUD</p>
				<ul>
					<li><p><a href="https://wellerqu.github.io/entity-framework-of-fe/">API Guide</a></p>
					</li>
					<li><p><a href="https://github.com/WellerQu/entity-framework-of-fe">Github</a></p>
					</li>
				</ul>
				<a href="#定义实体模型" id="定义实体模型" style="color: inherit; text-decoration: none;">
					<h2>定义实体模型</h2>
				</a>
				<p>实体是用于描述一种数据的数据结构, 实体的实例在Entity Framework(以后简称为EF)中定义成<strong>一个class的实例, 而非原生的JSON数据</strong>, 例如:</p>
				<pre><code class="language-typescript"><span class="hljs-comment">// Wrong ❌</span>
<span class="hljs-keyword">const</span> foo = { id: <span class="hljs-number">1</span>, name: <span class="hljs-string">'foo'</span> }

<span class="hljs-comment">// Right ✅</span>
<span class="hljs-keyword">class</span> Foo {
  id: <span class="hljs-built_in">number</span>
  name: <span class="hljs-built_in">string</span>
}

<span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">new</span> Foo()</code></pre>
				<a href="#描述实体模型" id="描述实体模型" style="color: inherit; text-decoration: none;">
					<h2>描述实体模型</h2>
				</a>
				<p>EF中, 采用注解来描述代表实体数据结构的class, 目前一共有二类注解</p>
				<ul>
					<li><p>类注解</p>
						<pre><code class="language-typescript"><span class="hljs-meta">@behavior</span>(<span class="hljs-string">'load'</span>, <span class="hljs-string">`<span class="hljs-subst">${domain}</span>/foo/$id`</span>, <span class="hljs-string">'GET'</span>)
<span class="hljs-keyword">class</span> Foo {
  <span class="hljs-comment">// define ...</span>
}</code></pre>
						<ul>
							<li>@behavior() 用于注解实体拥有的行为, 在调用相关方法时, 会触发这些行为</li>
						</ul>
						<blockquote>
							<p>完整签名查看源代码 src/annotations/object/behavior.ts</p>
						</blockquote>
						<pre><code class="language-typescript"><span class="hljs-meta">@behavior</span>(<span class="hljs-string">'load'</span>, <span class="hljs-string">`http://localhost:3000/foo/$id`</span>, <span class="hljs-string">'GET'</span>)
<span class="hljs-keyword">class</span> Foo {
  <span class="hljs-meta">@primary</span>()
  id: <span class="hljs-built_in">number</span>
}

<span class="hljs-keyword">const</span> ctx = <span class="hljs-keyword">new</span> Context()
<span class="hljs-comment">// 加载主键为1的Foo的数据</span>
<span class="hljs-keyword">await</span> ctx.foo.load(<span class="hljs-number">1</span>)
<span class="hljs-comment">// 在调用load方法时, 会向 http://localhost:3000/foo/$id 发起 GET 请求, 并在请求前将 $id 替换为 1</span></code></pre>
					</li>
					<li><p>属性注解</p>
						<pre><code class="language-typescript"><span class="hljs-keyword">class</span> Bar {
  <span class="hljs-comment">// define ...</span>
}

<span class="hljs-keyword">class</span> Foo {
  <span class="hljs-meta">@primary</span>()
  id: <span class="hljs-built_in">number</span>

  <span class="hljs-meta">@member</span>()
  name: <span class="hljs-built_in">string</span>

  <span class="hljs-meta">@foreign</span>(Bar, <span class="hljs-string">'bar'</span>)
  bid: <span class="hljs-built_in">number</span>

  <span class="hljs-meta">@navigator</span>(Relationship.One, <span class="hljs-string">'bar'</span>)
  bar?: Bar
}</code></pre>
						<ul>
							<li>@primary() 用于注解实体的主键, 实体的主键可以由多个主键组成组合键, 主键用于查询数据</li>
						</ul>
						<blockquote>
							<p>完整签名查看源代码 src/annotations/property/primary.ts</p>
						</blockquote>
						<ul>
							<li>@member() 用于注解实体的各个成员字段, 被标记为@member的成员字段将会被持久化</li>
						</ul>
						<blockquote>
							<p>完整签名查看源代码 src/annotations/property/member.ts</p>
						</blockquote>
						<ul>
							<li>@foreign() 用于注解实体的外键, 当前实体的外键一定是另一个实体的主键, 如果另一个实体有多个主键, 那么当前也需要对应的有多个外键</li>
						</ul>
						<blockquote>
							<p>完整签名查看源代码 src/annotations/property/foreign.ts</p>
						</blockquote>
						<ul>
							<li>@navigator() 用于注解实体的导航数据, 在通过外键读取到相关数据后, EF会将相关数据的引用存储在导航属性中, <strong>导航属性只需要声明, 不需要初始化</strong>,</li>
						</ul>
						<blockquote>
							<p>完整签名查看源代码 src/annotations/property/navigator.ts</p>
						</blockquote>
					</li>
				</ul>
				<a href="#关联实体模型" id="关联实体模型" style="color: inherit; text-decoration: none;">
					<h2>关联实体模型</h2>
				</a>
				<p>参考数据库设计, 可以用主外键来描述, 并部署相关的导航属性, 其中导航名称(navigatorName)是很重要的一个数据, 用来<strong>联系@set(), @foreign(), @navigator()标记的数据</strong>, 代码标记[1][2][3]处须一致</p>
				<pre><code class="language-typescript"><span class="hljs-keyword">class</span> Bar {
  <span class="hljs-meta">@primary</span>()
  id: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>
}

<span class="hljs-keyword">class</span> Haz {
  <span class="hljs-meta">@primary</span>()
  id: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>
}

<span class="hljs-keyword">class</span> Foo {
  <span class="hljs-meta">@primary</span>()
  id: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>

  <span class="hljs-comment">// Foo 与 Bar 是一对一关联</span>
  <span class="hljs-meta">@foreign</span>(Bar, <span class="hljs-string">'bar-navigatorName'</span>) <span class="hljs-comment">// &lt;- [1]</span>
  bid: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>

  <span class="hljs-comment">// Foo 与 Haz 是一对多关联</span>
  <span class="hljs-meta">@foreign</span>(Haz, <span class="hljs-string">'haz'</span>)
  hid: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">0</span>]

  <span class="hljs-meta">@navigator</span>(Relationship.One, <span class="hljs-string">'bar-navigatorName'</span>) <span class="hljs-comment">// &lt;- [2]</span>
  bar?: Bar

  <span class="hljs-meta">@navigator</span>(Relationship.Many, <span class="hljs-string">'haz'</span>)
  haz?: Haz[]
}

<span class="hljs-keyword">class</span> Context <span class="hljs-keyword">extends</span> EntityContext {
  <span class="hljs-meta">@set</span>(<span class="hljs-string">'bar-navigatorName'</span>) <span class="hljs-comment">// &lt;- [3]</span>
  bar = <span class="hljs-keyword">new</span> EntitySet&lt;Bar&gt;(<span class="hljs-keyword">this</span>, Bar)
}</code></pre>
				<a href="#entityset-与-entitycontext" id="entityset-与-entitycontext" style="color: inherit; text-decoration: none;">
					<h2>EntitySet 与 EntityContext</h2>
				</a>
				<ul>
					<li><p>EntitySet 是用来存储实体集合的, <strong>EntitySet字段的名称就是导航名称(navigatorName)</strong></p>
					</li>
					<li><p>EntityContext 是用来界定相关数据范围的</p>
						<pre><code class="language-typescript"><span class="hljs-comment">// 定义一个 Context</span>
<span class="hljs-keyword">class</span> MyContext <span class="hljs-keyword">extends</span> EntityContext {
  <span class="hljs-meta">@set</span>()
  foo = <span class="hljs-keyword">new</span> EntitySet&lt;Foo&gt;(<span class="hljs-keyword">this</span>, Foo)
  <span class="hljs-meta">@set</span>()
  bar = <span class="hljs-keyword">new</span> EntitySet&lt;Bar&gt;(<span class="hljs-keyword">this</span>, Bar)
  <span class="hljs-meta">@set</span>()
  haz = <span class="hljs-keyword">new</span> EntitySet&lt;Haz&gt;(<span class="hljs-keyword">this</span>, Haz)
}

<span class="hljs-comment">// 实例化 EntityContext</span>
<span class="hljs-keyword">const</span> ctx = <span class="hljs-keyword">new</span> MyContext()</code></pre>
					</li>
				</ul>
				<a href="#加载数据" id="加载数据" style="color: inherit; text-decoration: none;">
					<h2>加载数据</h2>
				</a>
				<p>加载数据是对数据进行各种操作的前提, 加载数据有二种方式, 用于应对二种情况</p>
				<pre><code class="language-typescript"><span class="hljs-meta">@behavior</span>(<span class="hljs-string">'load'</span>, <span class="hljs-string">'http://localhost:3000/foo/$pk'</span>, <span class="hljs-string">'GET'</span>)
<span class="hljs-meta">@behavior</span>(<span class="hljs-string">'loadAll'</span>, <span class="hljs-string">'http://localhost:3000/foo'</span>, <span class="hljs-string">'GET'</span>)
<span class="hljs-keyword">class</span> Foo {
  <span class="hljs-comment">// define ...</span>
}</code></pre>
				<ul>
					<li>Load 通过定义的主键(或者组合键)唯一实体数据, 需要先部署Load behavior</li>
				</ul>
				<pre><code class="language-typescript"><span class="hljs-comment">// 加载只有一个主键的数据</span>
<span class="hljs-comment">// http://localhost:3000/foo/$pk -&gt; http://localhost:3000/foo/1</span>
<span class="hljs-keyword">await</span> ctx.foo.load(<span class="hljs-number">1</span>)
<span class="hljs-comment">// 加载部署了组合键的数据</span>
<span class="hljs-comment">// http://localhost:3000/foo/$pk1/$pk2 -&gt; http://localhost:3000/foo/1/2</span>
<span class="hljs-comment">// 参数顺序为描述模型中@primary标记的顺序</span>
<span class="hljs-keyword">await</span> ctx.foo.load(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</code></pre>
				<ul>
					<li>LoadAll 通过传入的条件加载所有符合条件的数据</li>
				</ul>
				<pre><code class="language-typescript"><span class="hljs-comment">// 加载符合条件的所有数据</span>
<span class="hljs-keyword">await</span> ctx.foo.loadAll({
  <span class="hljs-comment">// anything</span>
})</code></pre>
				<p><strong>查询参数到RequestBody的映射</strong> 与 <strong>ResponseBody到实体数据的映射</strong>, 参见@behavior注解的mapParameters和mapEntity参数</p>
				<blockquote>
					<p>完整源代码参见 src/entitySet.ts</p>
				</blockquote>
				<ul>
					<li>include 加载关联的数据, <strong>在loadAll或者load一对多关系的实体时, 慎重使用include</strong></li>
				</ul>
				<pre><code class="language-typescript"><span class="hljs-comment">// 在加载主键为 1 的Foo的数据时, 将与Foo相关的Bar的数据也一并加载, 若Foo与Bar为一对一关系, EF会发起二个请求, 在Foo请求正确完成之后, 再发起对Bar的请求</span>
<span class="hljs-keyword">await</span> ctx.foo.include(<span class="hljs-string">'bar'</span>).load(<span class="hljs-number">1</span>)

<span class="hljs-comment">// 在加载完符合条件的Foo数据后, 将与Foo相关的Bar的数据也一并加载, 若Foo存在十条数据, 且Foo与Bar为一对一关系, EF会再并行发送十个请求, 用于加载对应的Bar数据</span>
<span class="hljs-keyword">await</span> ctx.foo.include(<span class="hljs-string">'bar'</span>).loadAll()</code></pre>
				<ul>
					<li>rawFetch 使用任意方法发起加载数据的请求, 并结果存储在EntitySet中, <strong>忽略include</strong></li>
				</ul>
				<pre><code class="language-typescript"><span class="hljs-keyword">await</span> ctx.foo.rawFetch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">window</span>.fetch(<span class="hljs-string">'/bar'</span>).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json()))</code></pre>
				<a href="#查询数据" id="查询数据" style="color: inherit; text-decoration: none;">
					<h2>查询数据</h2>
				</a>
				<p>在EF完成对数据的加载后, 就可以直接查询数据, 查询数据有二种方式, 分别应对二种情况</p>
				<ul>
					<li>find 通过主键(或组合键)查询唯一数据</li>
				</ul>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> foo: Foo = ctx.foo.find(<span class="hljs-number">1</span>)
<span class="hljs-comment">// or</span>
<span class="hljs-keyword">const</span> foo: Foo = ctx.foo.find(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</code></pre>
				<ul>
					<li>filter 通过filterCallback函数过滤数据</li>
				</ul>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> foo: Foo[] = ctx.foo.filter(<span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> n.id === <span class="hljs-number">1</span> || n.id === <span class="hljs-number">2</span>)</code></pre>
				<a href="#添加数据--修改数据--删除数据" id="添加数据--修改数据--删除数据" style="color: inherit; text-decoration: none;">
					<h2>添加数据 / 修改数据 / 删除数据</h2>
				</a>
				<ul>
					<li>saveChanges 将对EntitySet的修改同步到服务端. EF的Context会搜集数据集中各个元素的状态, saveChanges方法被调用时, 会检查这些状态的变更, 并对Added, Deleted, Modified做出反应, 尝试调用定义的@behavior来与服务端同步</li>
				</ul>
				<pre><code class="language-typescript"><span class="hljs-comment">// Add entity</span>
<span class="hljs-keyword">const</span> newFoo = <span class="hljs-keyword">new</span> Foo()
<span class="hljs-comment">// newFoo 赋值</span>
ctx.foo.add(newFoo)
<span class="hljs-comment">// 将调用@behavior('add', 'http://localhost:3000/foo', 'POST')定义的行为</span>
<span class="hljs-keyword">const</span> res: <span class="hljs-built_in">Promise</span>&lt;Response[]&gt; = <span class="hljs-keyword">await</span> ctx.saveChanges()
<span class="hljs-comment">// 检查res</span>

<span class="hljs-comment">// Update entity</span>
<span class="hljs-keyword">const</span> foo = ctx.foo.find(<span class="hljs-number">1</span>)
<span class="hljs-comment">// 只可以更新非主键成员字段</span>
foo.name = <span class="hljs-string">'Hello'</span>
<span class="hljs-comment">// 将调用@behavior('update', 'http://localhost:3000/foo', 'POST')定义的行为</span>
ctx.saveChanges()

<span class="hljs-comment">// Delete entity</span>
<span class="hljs-keyword">const</span> foo1 = ctx.foo.find(<span class="hljs-number">1</span>)
<span class="hljs-keyword">const</span> foo2 = ctx.foo.find(<span class="hljs-number">2</span>)
ctx.remove(foo1, foo2)
<span class="hljs-comment">// 将调用@behavior('delete', 'http://localhost:3000/foo', 'POST')定义的行为</span>
ctx.saveChanges()

<span class="hljs-comment">// CRUD the Included entity</span>
<span class="hljs-keyword">await</span> ctx.foo.include(<span class="hljs-string">'bar'</span>).load(<span class="hljs-number">1</span>)
<span class="hljs-keyword">const</span> foo = ctx.foo.find(<span class="hljs-number">1</span>)
foo.bar.name = <span class="hljs-string">'World'</span>
<span class="hljs-comment">// 将调用@behavior('update', 'http://localhost:3000/bar', 'POST')定义的行为</span>
ctx.saveChanges()

<span class="hljs-keyword">await</span> ctx.foo.include(<span class="hljs-string">'bar'</span>).load(<span class="hljs-number">1</span>)
<span class="hljs-keyword">const</span> foo = ctx.foo.find(<span class="hljs-number">1</span>)
ctx.bar.remove(foo.bar)
<span class="hljs-comment">// 将调用@behavior('delete', 'http://localhost:3000/bar', 'POST')定义的行为</span>
ctx.saveChanges()

<span class="hljs-keyword">await</span> ctx.foo.include(<span class="hljs-string">'jar'</span>).load(<span class="hljs-number">1</span>)
<span class="hljs-keyword">const</span> foo = ctx.foo.find(<span class="hljs-number">1</span>)
<span class="hljs-comment">// 若一个foo关联了二个jar, 那么ctx中将会有三个实体实例被标记为deleted, saveChanges会发出三个请求</span>
ctx.foo.remove(foo)
ctx.saveChange()</code></pre>
				<a href="#处理错误" id="处理错误" style="color: inherit; text-decoration: none;">
					<h2>处理错误</h2>
				</a>
				<ul>
					<li>当前加载数据时的部分错误被消化在Promise中, 并未全部都传递到调用端, 用户无法捕获正确的错误信息</li>
					<li>saveChanges时的错误能传递到调用端</li>
				</ul>
				<pre><code class="language-typescript"><span class="hljs-keyword">const</span> foo1 = <span class="hljs-keyword">new</span> Foo()
<span class="hljs-keyword">const</span> foo2 = <span class="hljs-keyword">new</span> Foo()
<span class="hljs-comment">// newFoo 赋值</span>
ctx.foo.add(foo1, foo2)
<span class="hljs-comment">// 将调用@behavior('add', 'http://localhost:3000/foo', 'POST')定义的行为二次</span>
<span class="hljs-keyword">const</span> res: <span class="hljs-built_in">Promise</span>&lt;Response[]&gt; = <span class="hljs-keyword">await</span> ctx.saveChanges()
<span class="hljs-comment">// res的Promise中将得到一个数组, 即二次请求的结果</span>
<span class="hljs-comment">// 检查res数据, 以确定每一个请求是否都正确完成</span></code></pre>
				<a href="#todo" id="todo" style="color: inherit; text-decoration: none;">
					<h2>TODO</h2>
				</a>
				<ul>
					<li>[] 补充关键代码注释</li>
					<li>[] 更精确的错误信息传递</li>
					<li>[] 数据缓存降低数据加载时对服务器的压力</li>
					<li>[] 更多场景的测试用例</li>
				</ul>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_annotations_metadatamanager_.html">&quot;annotations/metadata<wbr>Manager&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_annotations_metadatatype_.html">&quot;annotations/metadata<wbr>Type&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_annotations_object_behavior_.html">&quot;annotations/object/behavior&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_annotations_property_foreign_.html">&quot;annotations/property/foreign&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_annotations_property_member_.html">&quot;annotations/property/member&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_annotations_property_navigator_.html">&quot;annotations/property/navigator&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_annotations_property_primary_.html">&quot;annotations/property/primary&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_annotations_property_set_.html">&quot;annotations/property/set&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_annotations_relationship_.html">&quot;annotations/relationship&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_entityconfiguration_.html">&quot;entity<wbr>Configuration&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_entitycontext_.html">&quot;entity<wbr>Context&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_entityset_.html">&quot;entity<wbr>Set&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_entitystate_.html">&quot;entity<wbr>State&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_entitytrace_.html">&quot;entity<wbr>Trace&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_utils_isempty_.html">&quot;utils/is<wbr>Empty&quot;</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
				<li class="tsd-kind-type-alias tsd-has-type-parameter"><span class="tsd-kind-icon">Type alias with type parameter</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>